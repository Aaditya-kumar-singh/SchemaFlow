import { DiagramContent, DiagramNode } from '../../types/diagram';

export class MysqlExporter {
    static generate(diagram: DiagramContent): string {
        const tables = diagram.nodes.filter(n => n.type === 'mysqlTable');
        if (tables.length === 0) return '-- No MySQL tables found in diagram';

        let sql = `-- Generated by Moon Modeler\n-- Database: MySQL\n\n`;

        // 1. Create Tables
        tables.forEach(table => {
            sql += this.createTableSql(table);
        });

        sql += `\n-- Foreign Keys\n`;

        // 2. Foreign Keys
        // Strategy: Iterate edges. If Source Table has a field marked isForeignKey
        // AND that field name looks like it references Target (or generic FK), generate constraint.
        // Since we don't track Edge->Column binding strictly yet in the MVP store,
        // we'll assume valid relationships are drawn.

        diagram.edges.forEach(edge => {
            const sourceNode = tables.find(t => t.id === edge.source);
            const targetNode = tables.find(t => t.id === edge.target);

            if (sourceNode && targetNode) {
                // Strategy 1: Use explicit field mappings if available
                if (edge.data?.fieldMappings && edge.data.fieldMappings.length > 0) {
                    edge.data.fieldMappings.forEach(mapping => {
                        const sourceField = sourceNode.data.fields.find(f => f.name === mapping.sourceField);
                        // We rely on mapping.targetField. If not found, we rely on the string value.
                        if (sourceField) {
                            sql += this.createForeignKeySql(sourceNode, sourceField, targetNode, mapping.targetField, edge.data?.constraints);
                        }
                    });
                } else {
                    // Strategy 2: Fallback to naive detection (legacy support)
                    const fkField = sourceNode.data.fields.find(f => f.isForeignKey);
                    if (fkField) {
                        sql += this.createForeignKeySql(sourceNode, fkField, targetNode);
                    }
                }
            }
        });

        return sql;
    }

    private static createTableSql(table: DiagramNode): string {
        const tableName = table.data.label || 'untitled_table';

        const columnDefs = table.data.fields.map(field => {
            let colSql = `  \`${field.name}\` ${field.type}`;

            if (!field.isNullable) colSql += ' NOT NULL';
            // Primary key is handled at table level now
            if (field.isUnique && !field.isPrimaryKey) colSql += ' UNIQUE';

            return colSql;
        });

        // Handle Primary Keys (Composite or Single)
        const primaryKeys = table.data.fields
            .filter(f => f.isPrimaryKey)
            .map(f => `\`${f.name}\``);

        const definitions = [...columnDefs];

        if (primaryKeys.length > 0) {
            definitions.push(`  PRIMARY KEY (${primaryKeys.join(', ')})`);
        }

        // Add explicit indexes
        const indexes = table.data.fields
            .filter(f => f.isIndex && !f.isPrimaryKey && !f.isUnique)
            .map(f => `  INDEX \`idx_${tableName}_${f.name}\` (\`${f.name}\`)`);

        const allDefinitions = [...definitions, ...indexes];

        return `CREATE TABLE \`${tableName}\` (\n${allDefinitions.join(',\n')}\n);\n\n`;
    }

    private static createForeignKeySql(
        source: DiagramNode,
        field: any,
        target: DiagramNode,
        targetCol?: string,
        constraints?: { onDelete?: string; onUpdate?: string }
    ): string {
        const sourceTable = source.data.label;
        const targetTable = target.data.label;
        const constraintName = `fk_${sourceTable}_${field.name}`;

        // Assume target PK is the first PK field found, or 'id', if specific targetCol not provided
        const targetPk = targetCol || target.data.fields.find(f => f.isPrimaryKey)?.name || 'id';

        let sql = `ALTER TABLE \`${sourceTable}\`\n  ADD CONSTRAINT \`${constraintName}\`\n  FOREIGN KEY (\`${field.name}\`)\n  REFERENCES \`${targetTable}\`(\`${targetPk}\`)`;

        if (constraints?.onDelete) sql += ` ON DELETE ${constraints.onDelete}`;
        if (constraints?.onUpdate) sql += ` ON UPDATE ${constraints.onUpdate}`;

        return sql + ';\n\n';
    }
}
