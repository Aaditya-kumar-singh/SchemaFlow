import { DiagramContent, DiagramNode } from '../../types/diagram';

export class MongoExporter {
    static generate(diagram: DiagramContent): string {
        const collections = diagram.nodes.filter(n => n.type === 'mongoCollection');
        if (collections.length === 0) return '// No MongoDB collections found in diagram';

        let script = `/**\n * Generated by Moon Modeler\n * Database: MongoDB\n */\n\n`;

        // 1. Validator Scripts
        script += `// --- MongoDB Validation Scripts ---\n\n`;
        collections.forEach(col => {
            script += this.createCollectionScript(col);
        });

        // 2. Indexes
        script += '\n// --- Indexes ---\n';
        collections.forEach(col => {
            const colName = col.data.label || 'untitled';
            col.data.fields.forEach(field => {
                if (field.isUnique) {
                    script += `db.${colName}.createIndex({ "${field.name}": 1 }, { unique: true });\n`;
                } else if (field.isIndex) {
                    script += `db.${colName}.createIndex({ "${field.name}": 1 });\n`;
                }
            });
        });

        // 3. Mongoose Schemas (Reference)
        script += `\n/* \n   --- Mongoose Schemas (Reference) ---\n   Copy these into your Mongoose models.\n*/\n\n`;
        collections.forEach(col => {
            script += this.createMongooseSchema(col, diagram.edges, diagram.nodes);
        });

        // 4. Aggregation Pipelines ($lookup)
        script += `\n/* \n   --- Aggregation Examples ($lookup) ---\n   Based on your defined relationships.\n*/\n\n`;
        diagram.edges.forEach(edge => {
            const sourceNode = collections.find(n => n.id === edge.source);
            const targetNode = collections.find(n => n.id === edge.target);

            if (sourceNode && targetNode && edge.data?.fieldMappings) {
                edge.data.fieldMappings.forEach(mapping => {
                    script += this.createLookupScript(
                        sourceNode.data.label,
                        targetNode.data.label,
                        mapping.sourceField,
                        mapping.targetField
                    );
                });
            }
        });

        return script;
    }

    private static createCollectionScript(node: DiagramNode): string {
        const colName = node.data.label || 'untitled_collection';
        const requiredFields: string[] = [];
        const properties: Record<string, any> = {};

        node.data.fields.forEach(field => {
            // Map types
            const bsonType = this.mapType(field.type);
            properties[field.name] = { bsonType };

            if (field.name === '_id') {
                // _id is implicit, but validator supports it
            }

            // Using !isNullable as required
            if (!field.isNullable && field.name !== '_id') {
                requiredFields.push(field.name);
            }
        });

        const validator = {
            $jsonSchema: {
                bsonType: 'object',
                required: requiredFields.length > 0 ? requiredFields : undefined,
                properties,
                additionalProperties: false
            }
        };

        // Formatting JSON
        const jsonString = JSON.stringify({ validator }, null, 2);

        return `db.createCollection("${colName}", ${jsonString});\n\n`;
    }

    private static createMongooseSchema(node: DiagramNode, edges: any[], allNodes: DiagramNode[]): string {
        const colName = node.data.label || 'untitled';
        const schemaName = colName.charAt(0).toUpperCase() + colName.slice(1) + 'Schema';
        let schemaStr = `const ${schemaName} = new mongoose.Schema({\n`;

        node.data.fields.forEach(field => {
            let fieldDef = `  ${field.name}: { type: ${this.mapMongooseType(field.type)}`;

            // Check for relationships (Foreign Keys -> Refs)
            // Find an edge where this node is the source, and the field is in the mapping
            const relationEdge = edges.find(e =>
                e.source === node.id &&
                e.data?.fieldMappings?.some((m: any) => m.sourceField === field.name)
            );

            if (relationEdge) {
                const targetNode = allNodes.find(n => n.id === relationEdge.target);
                if (targetNode) {
                    fieldDef = `  ${field.name}: { type: mongoose.Schema.Types.ObjectId, ref: '${targetNode.data.label}'`;
                }
            }

            if (!field.isNullable) fieldDef += `, required: true`;
            if (field.isUnique) fieldDef += `, unique: true`;
            if (field.defaultValue) fieldDef += `, default: ${field.defaultValue}`; // Be careful with string quotes here

            fieldDef += ` },\n`;
            schemaStr += fieldDef;
        });

        schemaStr += `}, { timestamps: true });\n\n`;
        return schemaStr;
    }

    private static createLookupScript(sourceCol: string, targetCol: string, localField: string, foreignField: string): string {
        return `// Join ${sourceCol} with ${targetCol}\ndb.${sourceCol}.aggregate([\n  {\n    $lookup: {\n      from: "${targetCol}",\n      localField: "${localField}",\n      foreignField: "${foreignField}",\n      as: "${targetCol.toLowerCase()}_details"\n    }\n  }\n]);\n\n`;
    }

    private static mapType(uiType: string): string {
        // ... (Keep existing JSON schema map if needed, or reuse)
        // This is for JSON Schema
        const lower = uiType.toLowerCase();
        if (lower.includes('int') || lower === 'number') return 'number';
        if (lower === 'boolean') return 'bool';
        if (lower === 'date') return 'date';
        if (lower === 'objectid') return 'objectId';
        if (lower === 'array') return 'array';
        if (lower === 'object') return 'object';
        return 'string';
    }

    private static mapMongooseType(uiType: string): string {
        const lower = uiType.toLowerCase();
        if (lower.includes('int') || lower === 'number') return 'Number';
        if (lower === 'boolean') return 'Boolean';
        if (lower === 'date') return 'Date';
        if (lower === 'objectid') return 'mongoose.Schema.Types.ObjectId';
        if (lower === 'array') return 'Array';
        if (lower === 'object') return 'Map'; // or Object
        return 'String';
    }
}
